%option nounput
%option noyywrap
%option yylineno

ws1		([ \f\n\r\t\v])
ws		({ws1}*)
dd		[0123456789]
any		(.|\n)

%x Wow
%x Very

%{
#include <cerrno>
#include <cinttypes>
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <exception>
#include <unistd.h>
#include <boost/random/mersenne_twister.hpp>

static std::string curr_fn;
static long curr_ln_off = 0;
static boost::mt19937_64 generator;

static void warn(const char *fmt, ...)
{
	std::va_list ap;
	if (!curr_fn.empty())
		std::fprintf(stderr, "%s:%ld: ",
		    curr_fn.c_str(), yylineno + curr_ln_off);
	va_start(ap, fmt);
	std::vfprintf(stderr, fmt, ap);
	std::putc('\n', stderr);
	std::fflush(stderr);
}

static void die(const char *fmt, ...)
{
	std::va_list ap;
	if (!curr_fn.empty())
		std::fprintf(stderr, "%s:%ld: ",
		    curr_fn.c_str(), yylineno + curr_ln_off);
	std::fputs("ERROR: ", stderr);
	va_start(ap, fmt);
	std::vfprintf(stderr, fmt, ap);
	std::putc('\n', stderr);
	std::fflush(stderr);
	throw std::exception();
}

static void blurt(const char *s, size_t n)
{
	ssize_t r;
	while (n != 0) {
		r = write(1, s, n);
		if (r < 0)
			die("cannot write output: %s", std::strerror(errno));
		/* note: r may be 0 */
		s += r;
		n -= r;
	}
}
%}

%%

"?"{ws}"<"{ws}">"	{
				char v[20];
				blurt(yytext + 1, yyleng - 2);
				int n = std::snprintf(v, sizeof v,
				    "0x%" PRIx64 ">", generator());
				if (n <= 0 || (size_t)n >= sizeof v) {
					std::cerr << "lolwut?!?!?\n";
					return 1;
				}
				blurt(v, (size_t)n);
			}
"?"{ws}"<"{ws}		{
				char v[20];
				blurt(yytext + 1, yyleng - 1);
				int n = std::snprintf(v, sizeof v,
				    "0x%" PRIx64 ",", generator());
				if (n <= 0 || (size_t)n >= sizeof v) {
					std::cerr << "lolwut?!?!?\n";
					return 1;
				}
				blurt(v, (size_t)n);
			}
^{ws}"#"{ws}		{
				blurt(yytext, yyleng);
				BEGIN(Wow);
			}
"?"{ws}			|
[^\"\'#?\n]+		|
\"([^\"\\\n]|\\{any})*\"	|
\"([^\"\\\n]|\\{any})*\\	|
\"([^\"\\\n]|\\{any})*		|
'([^'\\\n]|\\{any})*'	|
'([^'\\\n]|\\{any})*\\	|
'([^'\\\n]|\\{any})*	|
^{ws1}{ws}		|
\n+			|
.			{ blurt(yytext, yyleng); }

<Wow>line{ws}		{ blurt(yytext, yyleng); }
<Wow>{dd}+{ws}		{
				blurt(yytext, yyleng);
				long no = strtol(yytext, 0, 10);
				curr_ln_off = no - 1 - yylineno;
				BEGIN(Very);
			}
<Wow>lin		|
<Wow>li			|
<Wow>.			|
<Wow>\n+		{
				blurt(yytext, yyleng);
				BEGIN(INITIAL);
			}

<Very>\"([^\"\\\n]|\\.)*\" {
				blurt(yytext, yyleng);
				/*
				 * By right we should be interpreting the
				 * escapes in the string, but I am too lazy
				 * to implement that...
				 */
				curr_fn = yytext + 1;
				curr_fn.pop_back();
				BEGIN(INITIAL);
			}
<Very>\"([^\"\\\n]|\\.)*\\	|
<Very>\"([^\"\\\n]|\\.)*	|
<Very>[^\"]		{
				warn("file name string not terminated on "
				     "same line");
				blurt(yytext, yyleng);
				BEGIN(INITIAL);
			}

%%

int main(int argc, char **argv)
{
	try {
		switch (argc) {
		    case 1:
			generator.seed(std::time(0) << 12 ^ getpid());  break;
		    case 2:
			generator.seed((uint64_t)std::strtoumax(argv[1],0,0));
			break;
		    default:
			die("usage: %s [(seed)]", argv[0]);
		}
		return yylex();
	} catch (std::exception& ex)
		{ return 1; }
}
